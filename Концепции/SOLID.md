# SOLID

S: Single Responsibility Principle (Принцип единственной ответственности). \
O: Open-Closed Principle (Принцип открытости-закрытости). \
L: Liskov Substitution Principle (Принцип подстановки Барбары Лисков). \
I: Interface Segregation Principle (Принцип разделения интерфейса). \
D: Dependency Inversion Principle (Принцип инверсии зависимостей). 

## Принцип единственной ответственности

Класс должен быть ответственен лишь за что-то одно. 
Если класс отвечает за решение нескольких задач, его подсистемы, реализующие решение этих задач, 
оказываются связанными друг с другом. Изменения в одной такой подсистеме ведут к изменениям в другой.

```
class Animal {
    constructor(name: string){ }
    getAnimalName() { }
    saveAnimal(a: Animal) { }
}
```
Класс Animal, представленный здесь, описывает какое-то животное. 
Этот класс нарушает принцип единственной ответственности. 
Как именно нарушается этот принцип?

В соответствии с принципом единственной ответственности класс должен решать лишь какую-то одну задачу. 
Он же решает две, занимаясь работой с хранилищем данных в методе saveAnimal и манипулируя 
свойствами объекта в конструкторе и в методе getAnimalName.

Вот что по этому поводу говорит Стив Фентон: «Проектируя классы, мы должны стремиться к тому, чтобы объединять родственные 
компоненты, то есть такие, изменения в которых происходят по одним и тем же причинам. Нам следует стараться разделять компоненты, 
изменения в которых вызывают различные причины».

## Принцип открытости-закрытости

Программные сущности (классы, модули, функции) должны быть открыты для расширения, но не для модификации.

```
class Animal {
    constructor(name: string){ }
    getAnimalName() { }
    saveAnimal(a: Animal) { }
}
```
