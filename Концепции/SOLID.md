# SOLID

S: Single Responsibility Principle (Принцип единственной ответственности). \
O: Open-Closed Principle (Принцип открытости-закрытости). \
L: Liskov Substitution Principle (Принцип подстановки Барбары Лисков). \
I: Interface Segregation Principle (Принцип разделения интерфейса). \
D: Dependency Inversion Principle (Принцип инверсии зависимостей). 

## Принцип единственной ответственности

Класс должен быть ответственен лишь за что-то одно. 
Если класс отвечает за решение нескольких задач, его подсистемы, реализующие решение этих задач, 
оказываются связанными друг с другом. Изменения в одной такой подсистеме ведут к изменениям в другой.

```
class Animal {
    constructor(name: string){ }
    getAnimalName() { }
    saveAnimal(a: Animal) { }
}
```
Класс Animal, представленный здесь, описывает какое-то животное. 
Этот класс нарушает принцип единственной ответственности. 
Как именно нарушается этот принцип?

В соответствии с принципом единственной ответственности класс должен решать лишь какую-то одну задачу. 
Он же решает две, занимаясь работой с хранилищем данных в методе saveAnimal и манипулируя 
свойствами объекта в конструкторе и в методе getAnimalName.

Вот что по этому поводу говорит Стив Фентон: «Проектируя классы, мы должны стремиться к тому, чтобы объединять родственные 
компоненты, то есть такие, изменения в которых происходят по одним и тем же причинам. Нам следует стараться разделять компоненты, 
изменения в которых вызывают различные причины».

## Принцип открытости-закрытости

Программные сущности (классы, модули, функции) должны быть открыты для расширения, но не для модификации.

## Принцип подстановки Барбары Лисков

Необходимо, чтобы подклассы могли бы служить заменой для своих суперклассов.

Цель этого принципа заключаются в том, чтобы классы-наследники могли бы использоваться вместо родительских классов, 
от которых они образованы, не нарушая работу программы. Если оказывается, что в коде проверяется тип класса, значит принцип подстановки нарушается.

Требования, сформулированные Стивом Фентоном. Методы, принимающие или возвращающие значения с типом некоего суперкласса 
должны также принимать и возвращать значения, типами которых являются его подклассы.

## Принцип разделения интерфейса

Создавайте узкоспециализированные интерфейсы, предназначенные для конкретного клиента. 
Клиенты не должны зависеть от интерфейсов, которые они не используют.

## Принцип инверсии зависимостей

Объектом зависимости должна быть абстракция, а не что-то конкретное.

1) Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
2) Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

В процессе разработки программного обеспечения существует момент, когда функционал приложения перестаёт помещаться в рамках одного модуля. Когда это происходит, нам приходится решать проблему зависимостей модулей. В результате, например, может оказаться так, что высокоуровневые компоненты зависят от низкоуровневых компонентов.

