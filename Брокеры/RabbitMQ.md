## Основные понятия

<image src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/8bc/270/795/8bc27079545d3f8e284fd8bb39128d27.png" alt="Текст с описанием картинки">
  
Publisher — публикует (паблишит) сообщения в Rabbit.

Exchange — обменник. Сущность Rabbit, точка входа для публикации всех сообщений.

Binding — связь между Exchange и очередью.

Queue — очередь для хранения сообщений.

Messages — сообщение, атомарная сущность.

Consumer — подписывается на очередь и получает от Rabbit сообщения. 

Publishing — процесс публикования сообщений в обменник.

Consuming — процесс подписывания consumer ***на очередь и получение им сообщений.

Routing Key — свойство Binding.

Persistent — свойство сохранения данных при перезагрузке сервиса (также известное как стейт).
  
  ## Publisher
  
  Создаёт соединение (connection) по протоколу AMQP, в рамках соединения создаёт канал (channel). 
  В рамках одного соединения можно создать несколько каналов, но это не рекомендуется даже официальной документацией RabbitMQ.
  
  Publisher может декларировать практически все сущности — exchanges, queues, bindings и др. 
  На практике лучше подходит стратегия декларирования всех нужных сущностей consumer, но решать нужно для каждого проекта индивидуально.
  
  Publisher определяет delivery_mode для каждого сообщения — так называемый «признак персистентности». 
  Это значит, что сообщение будет сохранено на диске и не исчезнет в случае перезагрузки Rabbit.

  1) delivery_mode=1 — не хранить сообщения, быстрее.
  2) delivery_mode=2 — хранить сообщения на диске, медленнее, но надёжнее.
  
  Также publisher определяет Routing Key для каждого сообщения — признак, по которому идёт дальнейшая маршрутизация в Rabbit.
  
  Publisher может выставлять confirm флаг — отправлять указания Rabbitmq через отдельный канал подтверждения об успешной приёмке сообщений. 
  
  Флаг mandatory — указание Rabbit складировать сообщения, не имеющие маршрута в какую-либо очередь в отдельный Exchange
  
  ## Exchange
  
  Неизменяемая сущность: для изменения параметров Exchange нужно его удалять и декларировать заново.

  Binding: не являются частью Exchange, можно менять отдельно.

  Рассылает сообщение во все очереди с подходящими binding (но не более одного сообщения в одну очередь, если есть несколько подходящих binding).

  Durable/Transient — признак персистентности Exchange. Durable означает, что exchange сохранится после перезагрузки Rabbit.

  Exchange не подразумевает хранения! Это не очередь. Если маршрут для сообщения не будет найден, сообщение сразу будет отброшено без возможности его восстановления.
  
  ## Binding
  
  Неизменяемая сущность: если нужно изменить binding, его удаляют и декларируют заново.

  Bindings между парой exchange-очередь может быть несколько, но только с разными параметрами.

  Параметры binding — или routingkey, или headers — в зависимости от типа Exchange.
  
  ## Типы Exchange
  
  Fanout

  Direct

  Topic

  Headers
  
  ### Fanout
  
  Exchange публикует сообщения во все очереди, в которых есть binding, игнорируя любые настройки binding (routing key или заголовки).

  Самый простой тип и наименее функциональный. Редко бывает нужен. По скоростям выдает на тестах около 30000mps, но столько же выдает и тип Direct.
  
  ### Direct
  
  Exchange публикует сообщения во все очереди, в которых Routing Key binding полностью совпадает с Routing Key Messages.

  Наиболее популярный тип, по скорости сравнимый с fanout (на тестах не увидел разницы) и при этом обладающий необходимой гибкостью для большинства задач.
  
  ### Topic
  
  Тип Exchange, похожий на Direct, но поддерживающий в качестве параметров binding Wildcard * и #, где:

  '*' - совпадение одного слова (слова разделяются точкой);

  '#' - любое количество слов. 

  Производительность топика на тестах показала скорости в три раза ниже fanaut/direct — не более 5000-10000mps
  
  ### Headers 
  
  Наиболее гибкий, но наименее производительный тип. Скорости очень сильно зависят от сложности условий и поэтому труднопрогнозируемы. Оперирует не Routing key, а заголовками сообщений и binding. В binding указываются ожидаемые заголовки, а также признак x-match, где:

  x-match=all — необходимы все совпадения для попадания сообщения;

  x-match=any — необходимо хотя бы одно совпадение.
  
  ## Queue
  
  Базовая сущность RabbitMQ, представляет из себя последовательное хранилище для необработанных сообщений.

  Хранение сообщений на диске (persistent) зависит от флага delivery_mode, назначаемым publisher для каждого сообщения.

  Durable/Transient — признак персистентности очереди. Durable значит, что exchange сохранится после перезагрузки Rabbit.
  
  Есть три типа очередей:

  1) Classic — обычная очередь, используется в большинстве случаев.

  2) Quorum — аналог классической очереди, но с обеспечением гарантий консистентности, достигаемый кворумом в кластере.

  3) Stream — новый вид очередей (начиная с версии Rabbimq 3.9), пока ещё мало кем используемый, аналог принципов Apache Kafka.

  ## Message
  
  Базовая сущность RabbitMQ — само сообщение, несёт полезную нагрузку (payload), проходит весь путь от Publisher до Consumer.

  Важные поля:

  1) payload — полезная нагрузка, может быть как string, так и base64. Можно закидывать туда хоть картинки, но потом не надо удивляться огромным трафикам между сервисами. Теоретический лимит размера одного сообщения — 2Gb, но на практике рекомендуемый размер сообщения 128mb;

  2) routing key — ключ маршрутизации, может быть только один для одного сообщения;

  3) delivery_mode — признак персистентности;

  4) headers — заголовки сообщения. Нужны для работы Exchange типа headers, а также для дополнительных возможностей Rabbit типа TTL.
  
  ## Consumer
  
  Замыкает обработку Сonsumer — демон, получающий сообщения из Queue и выполняющий ту самую логику, ради которой сообщение проделало весь этот путь. 
  Например, отправка уведомления, запись в базу данных, генерация оффлайн отчёта или отправка сообщения в другую Queue.

  Так же, как и Publisher, Consumer создаёт соединение (connection) по протоколу AMQP. 
  В рамках соединения создаёт канал (channel) и уже инициирует consuming в рамках этого канала.

  Consumer может декларировать практически все сущности — exchanges, queues, bindings и тд. 
  На практике мы стараемся декларировать все сущности именно Consumer, но решать нужно для каждого проекта индивидуально.
  
  Prefetch count — важный параметр Consumer, обозначающий количество неподтверждённых Consumer сообщений в один момент. 
  По умолчанию во многих библиотеках он равен 0 (по сути отключен). В такой ситуации Rabbit проталкивает все сообщения из очереди в Consumer, 
  а тот во многих случаях при достаточном количестве сообщений просто отъезжает.
  
  Consumer может подтвердить обработку сообщения — механизм Acknowledge (ack). 
  Или вернуть сообщение в Queue при неудачной обработке — механизм Negative acknowledge (nack).
  
  AutoAck — флаг автоматического подтверждения всех протакливаемых сообщений (не требует ack от Consumer). 
  Работает быстро, но не даёт никаких гарантий успешной обработки сообщений.
  
  
